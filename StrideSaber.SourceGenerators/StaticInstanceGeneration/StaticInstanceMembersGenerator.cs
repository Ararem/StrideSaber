using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using static StrideSaber.SourceGenerators.Helper.DocumentationHelper;

namespace StrideSaber.SourceGenerators.StaticInstanceGeneration
{
	/// <inheritdoc/>
	[Generator]
	public sealed class StaticInstanceMembersGenerator : ISourceGenerator
	{
		/// <inheritdoc/>
		public void Initialize(GeneratorInitializationContext ctx)
		{
			// Register a factory that can create our custom syntax receiver
			ctx.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
			//This is awesome by the way!!!
			// #if DEBUG
			// if (!Debugger.IsAttached) Debugger.Launch();
			// #endif
		}

		//From my understanding, the syntax receiver is the "scan" phase that finds stuff to work on,
		//and the "execute" is where we actually do the work
		/// <inheritdoc/>
		public void Execute(GeneratorExecutionContext context)
		{
			SyntaxReceiver receiver = (SyntaxReceiver) context.SyntaxContextReceiver!;

			//Create a StringBuilder to reuse
			StringBuilder sb = new(16384);
			INamedTypeSymbol genMembersAttributeSymbol = context.Compilation.GetTypeByMetadataName(typeof(GenerateStaticInstanceMembersAttribute).FullName!)!;
			Log($"GenMembers Attribute Symbol is {genMembersAttributeSymbol}");
			foreach (var type in receiver!.Types) ProcessType(type, context, sb, genMembersAttributeSymbol);

			//Here we write to our log file
			lock (_log)
			{
				StringBuilder logBuilder = new($"===== {DateTime.Now} ====={Environment.NewLine}");
				for (int i = 0; i < _log.Count; i++) logBuilder.AppendLine(_log[i]);
				_log.Clear();
				context.AddSource("SourceGenLog", SourceText.From($"/*{Environment.NewLine}{logBuilder}{Environment.NewLine}*/", Encoding.UTF8));
			}
		}

		/// <summary>
		/// Processes a given <see cref="ITypeSymbol"/>, generating static instance members for it
		/// </summary>
		/// <param name="toProcess"></param>
		/// <param name="context"></param>
		/// <param name="sb"></param>
		private static void ProcessType(TypeToProcess toProcess, GeneratorExecutionContext context, in StringBuilder sb, INamedTypeSymbol genMembersAttributeSymbol)
		{
			INamedTypeSymbol type = toProcess.Type;
			sb.Clear();
			Log($"\nExamining type {type}");

			//Check if it is actually something we should generate
			//So if we don't have any attributes that match our 'generate members on this' attribute we return
			AttributeData? genAttribute = type.GetAttributes().FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, genMembersAttributeSymbol));
			if (genAttribute is null)
			{
				Log("Class not marked for generation, skipping");
				return;
			}

			Log("Type marked for generation, processing");

			//Ensure the class is top-level (not a nested class)
			if (!SymbolEqualityComparer.Default.Equals(type.ContainingSymbol, type.ContainingNamespace))
			{
				Log($"\tType is not top level (Nested in {type.ContainingSymbol})");
				ReportDiag(ClassMustBeTopLevel, type);
				return;
			}

			//Also check for static-ness
			if (type.IsStatic)
			{
				Log("\tType is static");
				ReportDiag(ClassIsStatic, type);
				return;
			}

			Log("\tPreparing to generate static class version");
			string newTypeNamespace = genAttribute.ConstructorArguments[0].Value!.ToString() ?? $"{type.ContainingNamespace}.Generated";
			string newTypeName = genAttribute.ConstructorArguments[1].Value!.ToString() ?? $"Static_{type.Name}";
			string instanceName = genAttribute.ConstructorArguments[2].Value!.ToString() ?? "__instance";
			Log("\tGenerating class");
			//TODO: Handle if it's in the global namespace
			sb.Append($@"//Auto generated by a roslyn source generator
namespace {newTypeNamespace}
{{
	//Source type is {type}
	///{Inheritdoc(type)}
	public partial class {newTypeName}
	{{");
			Log($"\t\tGenerating target instance as '{instanceName}'");
			sb.Append($@"
		/// <summary>
		///  A roslyn source-generator generated instance that will be used as the target for static instance members
		/// </summary>
		[System.Runtime.CompilerServices.CompilerGenerated]
		private static readonly {type.Name} {instanceName} = new();");

			//Now we generate a static version of each instance member
			//Only generate public instance members
			//TODO: Handle non-public members
			var members = type.GetMembers().Where(m => !m.IsStatic && (m.DeclaredAccessibility == Accessibility.Public)).ToArray();
			Log($"\t\tFound {members.Length} members");
			foreach (var member in members)
			{
				switch (member)
				{
					case IFieldSymbol field:
						Log($"\t\tGenerating field {field.Name}");
						sb.Append($@"

		///{Inheritdoc(field)}
		public static {field.Type} {field.Name}
		{{
			get => {instanceName}.{field.Name};
			set => {instanceName}.{field.Name} = value;
		}}");
						break;

					//Todo: Get, init, etc
					case IPropertySymbol prop:
						Log($"\t\tGenerating property {prop.Name}");
						sb.Append($@"

		///{Inheritdoc(prop)}
		public static {prop.Type} {prop.Name}
		{{
			get => {instanceName}.{prop.Name};
			set => {instanceName}.{prop.Name} = value;
		}}");
						break;

					//Todo, generics, async, other method kinds, etc
					case IMethodSymbol {MethodKind: MethodKind.Ordinary} method:
						Log($"\t\tGenerating method {method}");
						//Build the return type strings
						string returnType = "";
						if (method.IsAsync) returnType += "async ";
						if (method.ReturnsByRefReadonly) returnType += "ref readonly ";
						else if (method.ReturnsByRef) returnType += "ref ";
						returnType += method.ReturnType;

						//Now build the parameters
						//methodCallArgs is when we actually call the method: `foo(x,y,z)`
						//methodDecArgs is when we declare the method: `foo(int x, int z, bar z)`
						//TODO: Nullable stuff
						string genericArgs = "", genericArgConstraints = "";
						if (method.IsGenericMethod)
						{
							genericArgs = $"<{string.Join(", ", method.TypeParameters.Select(t => t.Name))}>";
							foreach (ITypeParameterSymbol param in method.TypeParameters)
							{
								//If it has no constraints we skip this
								if (!param.HasConstructorConstraint && !param.HasNotNullConstraint && !param.HasReferenceTypeConstraint && !param.HasUnmanagedTypeConstraint && !param.HasValueTypeConstraint && (param.ConstraintTypes.Length == 0)) break;

								List<string> constraints = new();
								//Special constraints, such as new, notnull, etc come before type constraints
								if (param.HasReferenceTypeConstraint) constraints.Add("class");
								else if (param.HasUnmanagedTypeConstraint) constraints.Add("unmanaged");
								else if (param.HasValueTypeConstraint) constraints.Add("struct");
								else if (param.HasNotNullConstraint) constraints.Add("notnull");
								//Add all the `where T inherits from this class` constraints
								constraints.AddRange( param.ConstraintTypes.Select(t => $"{t}"));
								//The new constraint has to come last
								if (param.HasConstructorConstraint) constraints.Add("new()");
								genericArgConstraints += $"\n\t\t\twhere {param} : {string.Join(", ", constraints)}";
							}
						}
						string methodCallArgs = string.Join(", ", method.Parameters.Select(p => p.Name));
						string methodDecArgs = string.Join(", ", method.Parameters.Select(obj => $"{obj.Type} {obj.Name}"));

						sb.Append($@"

		///{Inheritdoc(method)}
		public static {returnType} {method.Name}{genericArgs}({methodDecArgs}){genericArgConstraints}
			=> {(method.IsAsync ? "await " : "")}{instanceName}.{method.Name}{genericArgs}({methodCallArgs});");
						break;

					//Handle cases we don't handle
					case IMethodSymbol {MethodKind: MethodKind.PropertyGet or MethodKind.PropertySet} method:
						Log($"\t\tSkipping property get/set method {method}");
						break;

					default:
						Log($"\t\tSkipping incompatible {member.Kind.ToString().ToLowerInvariant()} {member}");
						break;
				}
			}

			sb.Append(@"
	} //End class
} //End namespace
");
			context.AddSource($"{type.Name}__{newTypeName}", sb.ToString());

			void ReportDiag(DiagnosticDescriptor desc, ISymbol target)
			{
				//Gotta loop through all the locations the class was declared (partial classes)
				foreach (var loc in target.Locations)
					context.ReportDiagnostic(Diagnostic.Create(desc, loc));
			}
		}

		//TODO: add target member support
		private sealed record TypeToProcess(INamedTypeSymbol Type);

		/// <inheritdoc/>
		private sealed class SyntaxReceiver : ISyntaxContextReceiver
		{
			public readonly List<TypeToProcess> Types = new();

			/// <summary>
			///  Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
			/// </summary>
			public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
			{
				if (context.Node is TypeDeclarationSyntax typeDec and not InterfaceDeclarationSyntax)
				{
					//Get the symbol being declared by the type
					INamedTypeSymbol type = context.SemanticModel.GetDeclaredSymbol(typeDec)!;
					Types.Add(new TypeToProcess(type!));
				}
			}
		}

	#region Diagnostic Descriptions

		// ReSharper disable StringLiteralTypo

		//SIMG stands for "Static Instance Member Generator
		private static readonly DiagnosticDescriptor ClassMustBeTopLevel = new(
						"SIMG01",
						"Class must be top level",
						"The target class must not be a nested class (inside another class). It must be a class directly inside a namespace.",
						"Usage",
						DiagnosticSeverity.Error,
						true
				);

		private static readonly DiagnosticDescriptor ClassIsStatic = new(
						"SIMG02",
						"Class cannot be static",
						"The target class must not be static",
						"Usage",
						DiagnosticSeverity.Error,
						true
				);

		// ReSharper restore StringLiteralTypo

	#endregion

	#region Logging, ignore this

		/// <summary>
		///  Stores messages we need to log later
		/// </summary>
		// ReSharper disable once InconsistentNaming
		private static readonly List<string> _log = new();

		private static void Log(string s)
		{
			lock (_log)
			{
				_log.Add(s);
			}
		}

	#endregion
	}
}