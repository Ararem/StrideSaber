using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace StrideSaber.SourceGenerators.StaticInstanceGeneration
{
	/// <inheritdoc/>
	[Generator]
	public sealed class StaticInstanceMembersGenerator : ISourceGenerator
	{
		/// <inheritdoc/>
		public void Initialize(GeneratorInitializationContext ctx)
		{
			// Register a factory that can create our custom syntax receiver
			ctx.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
			//This is awesome by the way!!!
			// #if DEBUG
			// if (!Debugger.IsAttached) Debugger.Launch();
			// #endif
		}

		//From my understanding, the syntax receiver is the "scan" phase that finds stuff to work on,
		//and the "execute" is where we actually do the work
		/// <inheritdoc/>
		public void Execute(GeneratorExecutionContext context)
		{
			SyntaxReceiver receiver = (SyntaxReceiver) context.SyntaxContextReceiver!;

			//Create a StringBuilder to reuse
			StringBuilder sb = new(16384);
			INamedTypeSymbol genMembersAttributeSymbol = context.Compilation.GetTypeByMetadataName(typeof(GenerateStaticInstanceMembersAttribute).FullName!)!;
			Log($"GenMembers Attribute Symbol is {genMembersAttributeSymbol}");
			foreach (var type in receiver!.Types) ProcessType(type, context, sb, genMembersAttributeSymbol);

			//Here we write to our log file
			lock (_log)
			{
				StringBuilder logBuilder = new($"===== {DateTime.Now} ====={Environment.NewLine}");
				for (int i = 0; i < _log.Count; i++) logBuilder.AppendLine(_log[i]);
				_log.Clear();
				context.AddSource("SourceGenLog", SourceText.From($"/*{Environment.NewLine}{logBuilder}{Environment.NewLine}*/", Encoding.UTF8));
			}
		}

		/// <summary>
		/// Processes a given <see cref="ITypeSymbol"/>, generating static instance members for it
		/// </summary>
		/// <param name="toProcess"></param>
		/// <param name="context"></param>
		/// <param name="sb"></param>
		private static void ProcessType(TypeToProcess toProcess, GeneratorExecutionContext context, in StringBuilder sb, INamedTypeSymbol genMembersAttributeSymbol)
		{
			INamedTypeSymbol type = toProcess.Type;
			sb.Clear();
			Log($"\nExamining type {type}");

			//Check if it is actually something we should generate
			//So if we don't have any attributes that match our 'generate members on this' attribute we return
			AttributeData? genAttribute = type.GetAttributes().FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, genMembersAttributeSymbol));
			if (genAttribute is null)
			{
				Log("Class not marked for generation, skipping");
				return;
			}

			Log("Type marked for generation, processing");

			//Ensure the class is top-level (not a nested class)
			if (!SymbolEqualityComparer.Default.Equals(type.ContainingSymbol, type.ContainingNamespace))
			{
				Log($"Type is not top level (Nested in {type.ContainingSymbol})");
				ReportDiag(ClassMustBeTopLevel, type);
				return;
			}

			//Also check for static-ness
			if (type.IsStatic)
			{
				Log("Type is static");
				ReportDiag(ClassIsStatic, type);
				return;
			}

			Log("\tPreparing to generate static class version");
			string newTypeNamespace = genAttribute.ConstructorArguments[0].Value!.ToString() ?? $"{type.ContainingNamespace}.Generated";
			string newTypeName = genAttribute.ConstructorArguments[1].Value!.ToString() ?? $"Static_{type.Name}";
			string instanceName = genAttribute.ConstructorArguments[2].Value!.ToString() ?? "__instance";
			Log("\tGenerating class");
			//TODO: Handle if it's in the global namespace
			sb.Append($@"
//Auto generated by a roslyn source generator
namespace {newTypeNamespace}
{{
	//Source type is {(type.ContainingNamespace.IsGlobalNamespace ? "global::" : type.ContainingNamespace + ".")}{type.Name}
	///<inheritdoc cref=""{type.GetDocumentationCommentId()}""/>
	public partial class {newTypeName}
	{{");
			Log($"\t\tGenerating target instance as '{instanceName}'");
			sb.Append($@"
		/// <summary>
		///  A roslyn source-generator generated instance that will be used as the target for static instance members
		/// </summary>
		[System.Runtime.CompilerServices.CompilerGenerated]
		private static readonly {type.Name} {instanceName} = new();");

			//Now we generate a static version of each instance member
			//Only generate public instance members
			var members = type.GetMembers().Where(m => !m.IsStatic && (m.DeclaredAccessibility == Accessibility.Public)).ToArray();
			Log($"\t\tGenerating members (Count={members.Length})");
			foreach (var member in members)
			{
				switch (member)
				{
					case IFieldSymbol field:
						Log($"Generating field {field.Name}");
						sb.Append($@"
		{field.GetDocumentationCommentXml()}
		public static {field.Type.ContainingNamespace}.{field.Type.Name} {field.Name}
		{{
			get => {instanceName}.{field.Name};
			set => {instanceName}.{field.Name} = value;
		}}");
						break;

					//Todo: Get, init, etc
					case IPropertySymbol prop:
						Log($"Generating property {prop.Name}");
						sb.Append($@"
		{prop.GetDocumentationCommentXml()}
		public static {prop.Type.ContainingNamespace}.{prop.Type.Name} {prop.Name}
		{{
			get => {instanceName}.{prop.Name};
			set => {instanceName}.{prop.Name} = value;
		}}");
						break;

					//Todo, generics, async, etc
					case IMethodSymbol {MethodKind: MethodKind.Ordinary} method:
						//Build the return type strings
						string returnType = "";
						if (method.IsAsync) returnType += "async ";
						if (method.ReturnsByRefReadonly) returnType += "ref readonly ";
						else if (method.ReturnsByRef) returnType += "ref ";
						returnType += method.ReturnType;

						//Now build the parameters
						//methodCallArgs is when we actually call the method: `foo(x,y,z)`
						//methodDecArgs is when we declare the method: `foo(int x, int z, bar z)`
						//TODO: Perhaps use `string.Join()`
						//TODO: Nullable stuff
						string methodCallArgs = "", methodDecArgs = "";
						string genericArgs = "", genericArgConstraints = "";
						if (method.IsGenericMethod)
						{
							genericArgs = $"<{string.Join(", ", method.TypeParameters.Select(t => t.Name))}>";
							foreach (ITypeParameterSymbol param in method.TypeParameters)
							{
								var constraints = param.ConstraintTypes;
								for (int i = 0; i < constraints.Length; i++)
								{
									ITypeSymbol constraint = constraints[i];
									genericArgConstraints += $"where {param} : {constraint}";
									if (i != constraints.Length - 1) genericArgConstraints += ", ";
								}
							}
						}
						for (int i = 0; i < method.Parameters.Length; i++)
						{
							IParameterSymbol param = method.Parameters[i];
							//Append the types and names of the parameters
							methodCallArgs += param.Name;
							methodDecArgs += $"{param.Type} {param.Name}";

							//Only add commas on iterations that aren't the last
							if (i != method.Parameters.Length - 1)
							{
								methodCallArgs += ", ";
								methodDecArgs += ", ";
							}
						}

						sb.Append($@"
		{method.GetDocumentationCommentXml()}
		public static {returnType} {method.Name}{genericArgs}({methodDecArgs}) {genericArgConstraints} => {(method.IsAsync ? "await " : "")}{instanceName}.{method.Name}{genericArgs}({methodCallArgs});");
						break;
				}
			}

			sb.Append(@"
	} //Class
} //Namespace
");
			context.AddSource($"{type.Name}__{newTypeName}", sb.ToString());

			void ReportDiag(DiagnosticDescriptor desc, ISymbol target)
			{
				//Gotta loop through all the locations the class was declared (partial classes)
				foreach (var loc in target.Locations)
					context.ReportDiagnostic(Diagnostic.Create(desc, loc));
			}
		}

		//TODO: add target member support
		private sealed record TypeToProcess(INamedTypeSymbol Type);

		/// <inheritdoc/>
		private sealed class SyntaxReceiver : ISyntaxContextReceiver
		{
			public readonly List<TypeToProcess> Types = new();

			/// <summary>
			///  Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
			/// </summary>
			public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
			{
				if (context.Node is TypeDeclarationSyntax typeDec and not InterfaceDeclarationSyntax)
				{
					//Get the symbol being declared by the type
					INamedTypeSymbol type = context.SemanticModel.GetDeclaredSymbol(typeDec)!;
					Types.Add(new TypeToProcess(type!));
				}
			}
		}

	#region Diagnostic Descriptions

		// ReSharper disable StringLiteralTypo

		//SIMG stands for "Static Instance Member Generator
		private static readonly DiagnosticDescriptor ClassMustBeTopLevel = new(
						"SIMG01",
						"Class must be top level",
						"The target class must not be a nested class (inside another class). It must be a class directly inside a namespace.",
						"Usage",
						DiagnosticSeverity.Error,
						true
				);

		private static readonly DiagnosticDescriptor ClassIsStatic = new(
						"SIMG02",
						"Class cannot be static",
						"The target class must not be static",
						"Usage",
						DiagnosticSeverity.Error,
						true
				);

		// ReSharper restore StringLiteralTypo

	#endregion

	#region Logging, ignore this

		/// <summary>
		///  Stores messages we need to log later
		/// </summary>
		// ReSharper disable once InconsistentNaming
		private static readonly List<string> _log = new();

		private static void Log(string s)
		{
			lock (_log)
			{
				_log.Add(s);
			}
		}

	#endregion
	}
}